{"ast":null,"code":"/**\n * @author felixturner / http://airtight.cc/\n *\n * RGB Shift Shader\n * Shifts red and blue channels from center in opposite directions\n * Ported from http://kriss.cx/tom/2009/05/rgb-shift/\n * by Tom Butterworth / http://kriss.cx/tom/\n *\n * amount: shift distance (1 is width of input)\n * angle: shift angle in radians\n */\n\nvar DigitalGlitch = {\n  uniforms: {\n    \"tDiffuse\": {\n      value: null\n    },\n    //diffuse texture\n    \"tDisp\": {\n      value: null\n    },\n    //displacement texture for digital glitch squares\n    \"byp\": {\n      value: 0\n    },\n    //apply the glitch ?\n    \"amount\": {\n      value: 0.08\n    },\n    \"angle\": {\n      value: 0.02\n    },\n    \"seed\": {\n      value: 0.02\n    },\n    \"seed_x\": {\n      value: 0.02\n    },\n    //-1,1\n    \"seed_y\": {\n      value: 0.02\n    },\n    //-1,1\n    \"distortion_x\": {\n      value: 0.5\n    },\n    \"distortion_y\": {\n      value: 0.6\n    },\n    \"col_s\": {\n      value: 0.05\n    }\n  },\n  vertexShader: [\"varying vec2 vUv;\", \"void main() {\", \"vUv = uv;\", \"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n  fragmentShader: [\"uniform int byp;\",\n  //should we apply the glitch ?\n\n  \"uniform sampler2D tDiffuse;\", \"uniform sampler2D tDisp;\", \"uniform float amount;\", \"uniform float angle;\", \"uniform float seed;\", \"uniform float seed_x;\", \"uniform float seed_y;\", \"uniform float distortion_x;\", \"uniform float distortion_y;\", \"uniform float col_s;\", \"varying vec2 vUv;\", \"float rand(vec2 co){\", \"return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\", \"}\", \"void main() {\", \"if(byp<1) {\", \"vec2 p = vUv;\", \"float xs = floor(gl_FragCoord.x / 0.5);\", \"float ys = floor(gl_FragCoord.y / 0.5);\",\n  //based on staffantans glitch shader for unity https://github.com/staffantan/unityglitch\n  \"vec4 normal = texture2D (tDisp, p*seed*seed);\", \"if(p.y<distortion_x+col_s && p.y>distortion_x-col_s*seed) {\", \"if(seed_x>0.){\", \"p.y = 1. - (p.y + distortion_y);\", \"}\", \"else {\", \"p.y = distortion_y;\", \"}\", \"}\", \"if(p.x<distortion_y+col_s && p.x>distortion_y-col_s*seed) {\", \"if(seed_y>0.){\", \"p.x=distortion_x;\", \"}\", \"else {\", \"p.x = 1. - (p.x + distortion_x);\", \"}\", \"}\", \"p.x+=normal.x*seed_x*(seed/5.);\", \"p.y+=normal.y*seed_y*(seed/5.);\",\n  //base from RGB shift shader\n  \"vec2 offset = amount * vec2( cos(angle), sin(angle));\", \"vec4 cr = texture2D(tDiffuse, p + offset);\", \"vec4 cga = texture2D(tDiffuse, p);\", \"vec4 cb = texture2D(tDiffuse, p - offset);\", \"gl_FragColor = vec4(cr.r, cga.g, cb.b, cga.a);\",\n  //add noise\n  \"vec4 snow = 200.*amount*vec4(rand(vec2(xs * seed,ys * seed*50.))*0.2);\", \"gl_FragColor = gl_FragColor+ snow;\", \"}\", \"else {\", \"gl_FragColor=texture2D (tDiffuse, vUv);\", \"}\", \"}\"].join(\"\\n\")\n};\nexport { DigitalGlitch };","map":{"version":3,"names":["DigitalGlitch","uniforms","value","vertexShader","join","fragmentShader"],"sources":["C:/Users/gary-/Documents/MyProjects/Portfolio/Gary-Liang.github.io/frontend/node_modules/three/examples/jsm/shaders/DigitalGlitch.js"],"sourcesContent":["/**\n * @author felixturner / http://airtight.cc/\n *\n * RGB Shift Shader\n * Shifts red and blue channels from center in opposite directions\n * Ported from http://kriss.cx/tom/2009/05/rgb-shift/\n * by Tom Butterworth / http://kriss.cx/tom/\n *\n * amount: shift distance (1 is width of input)\n * angle: shift angle in radians\n */\n\n\n\nvar DigitalGlitch = {\n\n\tuniforms: {\n\n\t\t\"tDiffuse\": { value: null }, //diffuse texture\n\t\t\"tDisp\": { value: null }, //displacement texture for digital glitch squares\n\t\t\"byp\": { value: 0 }, //apply the glitch ?\n\t\t\"amount\": { value: 0.08 },\n\t\t\"angle\": { value: 0.02 },\n\t\t\"seed\": { value: 0.02 },\n\t\t\"seed_x\": { value: 0.02 }, //-1,1\n\t\t\"seed_y\": { value: 0.02 }, //-1,1\n\t\t\"distortion_x\": { value: 0.5 },\n\t\t\"distortion_y\": { value: 0.6 },\n\t\t\"col_s\": { value: 0.05 }\n\t},\n\n\tvertexShader: [\n\n\t\t\"varying vec2 vUv;\",\n\t\t\"void main() {\",\n\t\t\t\"vUv = uv;\",\n\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\t\t\"}\"\n\t].join( \"\\n\" ),\n\n\tfragmentShader: [\n\t\t\"uniform int byp;\",//should we apply the glitch ?\n\n\t\t\"uniform sampler2D tDiffuse;\",\n\t\t\"uniform sampler2D tDisp;\",\n\n\t\t\"uniform float amount;\",\n\t\t\"uniform float angle;\",\n\t\t\"uniform float seed;\",\n\t\t\"uniform float seed_x;\",\n\t\t\"uniform float seed_y;\",\n\t\t\"uniform float distortion_x;\",\n\t\t\"uniform float distortion_y;\",\n\t\t\"uniform float col_s;\",\n\n\t\t\"varying vec2 vUv;\",\n\n\n\t\t\"float rand(vec2 co){\",\n\t\t\t\"return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\",\n\t\t\"}\",\n\n\t\t\"void main() {\",\n\t\t\t\"if(byp<1) {\",\n\t\t\t\t\"vec2 p = vUv;\",\n\t\t\t\t\"float xs = floor(gl_FragCoord.x / 0.5);\",\n\t\t\t\t\"float ys = floor(gl_FragCoord.y / 0.5);\",\n\t\t\t\t//based on staffantans glitch shader for unity https://github.com/staffantan/unityglitch\n\t\t\t\t\"vec4 normal = texture2D (tDisp, p*seed*seed);\",\n\t\t\t\t\"if(p.y<distortion_x+col_s && p.y>distortion_x-col_s*seed) {\",\n\t\t\t\t\t\"if(seed_x>0.){\",\n\t\t\t\t\t\t\"p.y = 1. - (p.y + distortion_y);\",\n\t\t\t\t\t\"}\",\n\t\t\t\t\t\"else {\",\n\t\t\t\t\t\t\"p.y = distortion_y;\",\n\t\t\t\t\t\"}\",\n\t\t\t\t\"}\",\n\t\t\t\t\"if(p.x<distortion_y+col_s && p.x>distortion_y-col_s*seed) {\",\n\t\t\t\t\t\"if(seed_y>0.){\",\n\t\t\t\t\t\t\"p.x=distortion_x;\",\n\t\t\t\t\t\"}\",\n\t\t\t\t\t\"else {\",\n\t\t\t\t\t\t\"p.x = 1. - (p.x + distortion_x);\",\n\t\t\t\t\t\"}\",\n\t\t\t\t\"}\",\n\t\t\t\t\"p.x+=normal.x*seed_x*(seed/5.);\",\n\t\t\t\t\"p.y+=normal.y*seed_y*(seed/5.);\",\n\t\t\t\t//base from RGB shift shader\n\t\t\t\t\"vec2 offset = amount * vec2( cos(angle), sin(angle));\",\n\t\t\t\t\"vec4 cr = texture2D(tDiffuse, p + offset);\",\n\t\t\t\t\"vec4 cga = texture2D(tDiffuse, p);\",\n\t\t\t\t\"vec4 cb = texture2D(tDiffuse, p - offset);\",\n\t\t\t\t\"gl_FragColor = vec4(cr.r, cga.g, cb.b, cga.a);\",\n\t\t\t\t//add noise\n\t\t\t\t\"vec4 snow = 200.*amount*vec4(rand(vec2(xs * seed,ys * seed*50.))*0.2);\",\n\t\t\t\t\"gl_FragColor = gl_FragColor+ snow;\",\n\t\t\t\"}\",\n\t\t\t\"else {\",\n\t\t\t\t\"gl_FragColor=texture2D (tDiffuse, vUv);\",\n\t\t\t\"}\",\n\t\t\"}\"\n\n\t].join( \"\\n\" )\n\n};\n\nexport { DigitalGlitch };\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAIA,IAAIA,aAAa,GAAG;EAEnBC,QAAQ,EAAE;IAET,UAAU,EAAE;MAAEC,KAAK,EAAE;IAAK,CAAC;IAAE;IAC7B,OAAO,EAAE;MAAEA,KAAK,EAAE;IAAK,CAAC;IAAE;IAC1B,KAAK,EAAE;MAAEA,KAAK,EAAE;IAAE,CAAC;IAAE;IACrB,QAAQ,EAAE;MAAEA,KAAK,EAAE;IAAK,CAAC;IACzB,OAAO,EAAE;MAAEA,KAAK,EAAE;IAAK,CAAC;IACxB,MAAM,EAAE;MAAEA,KAAK,EAAE;IAAK,CAAC;IACvB,QAAQ,EAAE;MAAEA,KAAK,EAAE;IAAK,CAAC;IAAE;IAC3B,QAAQ,EAAE;MAAEA,KAAK,EAAE;IAAK,CAAC;IAAE;IAC3B,cAAc,EAAE;MAAEA,KAAK,EAAE;IAAI,CAAC;IAC9B,cAAc,EAAE;MAAEA,KAAK,EAAE;IAAI,CAAC;IAC9B,OAAO,EAAE;MAAEA,KAAK,EAAE;IAAK;EACxB,CAAC;EAEDC,YAAY,EAAE,CAEb,mBAAmB,EACnB,eAAe,EACd,WAAW,EACX,2EAA2E,EAC5E,GAAG,CACH,CAACC,IAAI,CAAE,IAAK,CAAC;EAEdC,cAAc,EAAE,CACf,kBAAkB;EAAC;;EAEnB,6BAA6B,EAC7B,0BAA0B,EAE1B,uBAAuB,EACvB,sBAAsB,EACtB,qBAAqB,EACrB,uBAAuB,EACvB,uBAAuB,EACvB,6BAA6B,EAC7B,6BAA6B,EAC7B,sBAAsB,EAEtB,mBAAmB,EAGnB,sBAAsB,EACrB,mEAAmE,EACpE,GAAG,EAEH,eAAe,EACd,aAAa,EACZ,eAAe,EACf,yCAAyC,EACzC,yCAAyC;EACzC;EACA,+CAA+C,EAC/C,6DAA6D,EAC5D,gBAAgB,EACf,kCAAkC,EACnC,GAAG,EACH,QAAQ,EACP,qBAAqB,EACtB,GAAG,EACJ,GAAG,EACH,6DAA6D,EAC5D,gBAAgB,EACf,mBAAmB,EACpB,GAAG,EACH,QAAQ,EACP,kCAAkC,EACnC,GAAG,EACJ,GAAG,EACH,iCAAiC,EACjC,iCAAiC;EACjC;EACA,uDAAuD,EACvD,4CAA4C,EAC5C,oCAAoC,EACpC,4CAA4C,EAC5C,gDAAgD;EAChD;EACA,wEAAwE,EACxE,oCAAoC,EACrC,GAAG,EACH,QAAQ,EACP,yCAAyC,EAC1C,GAAG,EACJ,GAAG,CAEH,CAACD,IAAI,CAAE,IAAK;AAEd,CAAC;AAED,SAASJ,aAAa"},"metadata":{},"sourceType":"module","externalDependencies":[]}